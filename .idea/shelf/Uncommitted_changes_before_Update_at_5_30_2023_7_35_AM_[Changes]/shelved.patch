Index: CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>cmake_minimum_required(VERSION 3.24)\nproject(COS314New)\n\nset(CMAKE_CXX_STANDARD 14)\n\ninclude_directories(Assignment3)\n\nadd_executable(COS314New\n        Assignment3/main.cpp\n        Assignment3/Network.cpp\n        Assignment3/Network.h)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	(revision c1a4f59bf892ab2c79fd3ee237dc3e84bf56f52e)
+++ b/CMakeLists.txt	(date 1685382639883)
@@ -7,5 +7,4 @@
 
 add_executable(COS314New
         Assignment3/main.cpp
-        Assignment3/Network.cpp
-        Assignment3/Network.h)
+        Assignment3/Neuron.h Assignment3/Network.h Assignment3/Network.cpp)
Index: Assignment3/main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <iostream>\n#include <vector>\n#include \"Network.h\"\nusing namespace std;\n\nint main() {\n\n    //if we send in { 3, 2, 1 }\n    //it is number of layers in input, hidden, output\n\n    vector<int> topology;\n    topology.push_back(3); //3 input layers\n    topology.push_back(2); //2 hidden layers\n    topology.push_back(1); //1 output layers\n    Network myNet(topology);\n\n    vector<double> inputVals;\n    myNet.feedForward(inputVals);\n\n    vector<double> targetVals;\n    myNet.backProp(targetVals);\n\n    vector<double> resultVals;\n    myNet.getResults(resultVals);\n\n    return 0;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment3/main.cpp b/Assignment3/main.cpp
--- a/Assignment3/main.cpp	(revision c1a4f59bf892ab2c79fd3ee237dc3e84bf56f52e)
+++ b/Assignment3/main.cpp	(date 1685382614575)
@@ -1,27 +1,35 @@
 #include <iostream>
-#include <vector>
-#include "Network.h"
+#include "Neuron.h"
 using namespace std;
 
 int main() {
 
-    //if we send in { 3, 2, 1 }
-    //it is number of layers in input, hidden, output
+
 
-    vector<int> topology;
-    topology.push_back(3); //3 input layers
-    topology.push_back(2); //2 hidden layers
-    topology.push_back(1); //1 output layers
-    Network myNet(topology);
+    const int INPUT_LAYER_NEURONS = 2;
+    const int HIDDEN_LAYER_NEURONS = 3;
+    const int OUTPUT_LAYER_NEURONS = 2;
 
-    vector<double> inputVals;
-    myNet.feedForward(inputVals);
+    for (int i = 0; i < INPUT_LAYER_NEURONS; i++)
+        inputLayer.push_back(Neuron());
 
-    vector<double> targetVals;
-    myNet.backProp(targetVals);
+    for (int i = 0; i < HIDDEN_LAYER_NEURONS; i++)
+        hiddenLayer.push_back(Neuron());
 
-    vector<double> resultVals;
-    myNet.getResults(resultVals);
+    for (int i = 0; i < OUTPUT_LAYER_NEURONS; i++)
+        outputLayer.push_back(Neuron());
+
+    // connect all the neurons to one another
+    for (Neuron n : inputLayer) {
+        n.setNextNeurons(hiddenLayer);
+    }
+    for (Neuron n : hiddenLayer) {
+        n.setNextNeurons(outputLayer);
+        n.setPrevNeurons(inputLayer);
+    }
+    for (Neuron n : outputLayer) {
+        n.setPrevNeurons(hiddenLayer);
+    }
 
     return 0;
 }
\ No newline at end of file
Index: Assignment3/Network.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <vector>\n\nclass Neuron{};\ntypedef std::vector<Neuron> Layer;\n\nclass Network {\nprivate:\n    //2D vecotr\n    std::vector<Layer> layers;\npublic:\n    Network(std::vector<int> topology);\n    void feedForward(const std::vector<double>& inputVals)\n\n\n\n\n\n    void backProp(const std::vector<double>& targetVals);\n    void getResults(std::vector<double>& inputVals) const;\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment3/Network.h b/Assignment3/Network.h
--- a/Assignment3/Network.h	(revision c1a4f59bf892ab2c79fd3ee237dc3e84bf56f52e)
+++ b/Assignment3/Network.h	(date 1685382633802)
@@ -1,20 +1,13 @@
+#pragma once;
+#include "Neuron.h"
 #include <vector>
 
-class Neuron{};
-typedef std::vector<Neuron> Layer;
-
 class Network {
 private:
-    //2D vecotr
-    std::vector<Layer> layers;
+    std::vector<Neuron> inputLayer;
+    std::vector<Neuron> hiddenLayer;
+    std::vector<Neuron> outputLayer;
 public:
-    Network(std::vector<int> topology);
-    void feedForward(const std::vector<double>& inputVals)
-
-
-
-
-
-    void backProp(const std::vector<double>& targetVals);
-    void getResults(std::vector<double>& inputVals) const;
+    Network(int inputLayerNeurons, int hiddenLayerNeurons,
+            int outputLayerNeurons);
 };
\ No newline at end of file
Index: Assignment3/Network.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Network.h\"\n\nNetwork::Network(std::vector<int> topology) {\n    for (int i = 0; i < topology.size(); i++) {\n        //add the layer (the column)\n        layers.push_back(Layer());\n\n        //add the neurons in the layer\n        for (int neuron = 0; neuron <= topology[i]; neuron++)\n            //append to the most recently added layer\n            layers.back().push_back(Neuron());\n    }\n}\n\nvoid Network::feedForward(const std::vector<double> &inputVals) {\n\n}\n\nvoid Network::backProp(const std::vector<double> &targetVals) {\n\n}\n\nvoid Network::getResults(std::vector<double> &inputVals) const {\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment3/Network.cpp b/Assignment3/Network.cpp
--- a/Assignment3/Network.cpp	(revision c1a4f59bf892ab2c79fd3ee237dc3e84bf56f52e)
+++ b/Assignment3/Network.cpp	(date 1685383401716)
@@ -1,25 +1,25 @@
 #include "Network.h"
 
-Network::Network(std::vector<int> topology) {
-    for (int i = 0; i < topology.size(); i++) {
-        //add the layer (the column)
-        layers.push_back(Layer());
+Network::Network(int inputLayerNeurons,
+                 int hiddenLayerNeurons, int outputLayerNeurons) {
 
-        //add the neurons in the layer
-        for (int neuron = 0; neuron <= topology[i]; neuron++)
-            //append to the most recently added layer
-            layers.back().push_back(Neuron());
-    }
-}
+    for (int i = 0; i < inputLayerNeurons; i++)
+        inputLayer.push_back(Neuron());
 
-void Network::feedForward(const std::vector<double> &inputVals) {
+    for (int i = 0; i < hiddenLayerNeurons; i++)
+        hiddenLayer.push_back(Neuron());
 
-}
+    for (int i = 0; i < outputLayerNeurons; i++)
+        outputLayer.push_back(Neuron());
 
-void Network::backProp(const std::vector<double> &targetVals) {
+    //connect each neuron in the input layer to all the
+    //other neurons in the hidden layer
+    for (int i = 0; i < inputLayerNeurons; i++)
+        inputLayer[i].setNextNeurons(hiddenLayer);
 
-}
-
-void Network::getResults(std::vector<double> &inputVals) const {
+    //connect each neuron in the hidden layer to all the
+    //other neurons in the output layer
+    for (int i = 0; i < hiddenLayerNeurons; i++)
+        hiddenLayer[i].setNextNeurons(outputLayer);
 
 }
\ No newline at end of file
Index: Assignment3/reference/main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment3/reference/main.cpp b/Assignment3/reference/main.cpp
new file mode 100644
--- /dev/null	(date 1685378966374)
+++ b/Assignment3/reference/main.cpp	(date 1685378966374)
@@ -0,0 +1,36 @@
+#include <iostream>
+#include <vector>
+#include "Network.h"
+using namespace std;
+
+int main() {
+
+    //if we send in { 3, 2, 1 }
+    //it is number of layers in input, hidden, output
+
+    vector<int> topology;
+    topology.push_back(3); //3 input layers
+    topology.push_back(2); //2 hidden layers
+    topology.push_back(1); //1 output layers
+    Network myNet(topology);
+
+    try {
+        vector<double> inputVals = { 3, 5, 1};
+        myNet.feedForward(inputVals);
+    }
+    catch (const char* err) {
+        cout << err << endl;
+    }
+
+    cout << "fed forward..." << endl;
+
+    vector<double> targetVals = { 1, 5 };
+    myNet.backProp(targetVals);
+
+    cout << "back prop done ..." << endl;
+
+    vector<double> resultVals;
+    myNet.getResults(resultVals);
+
+    return 0;
+}
\ No newline at end of file
Index: Assignment3/Neuron.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment3/Neuron.h b/Assignment3/Neuron.h
new file mode 100644
--- /dev/null	(date 1685383401736)
+++ b/Assignment3/Neuron.h	(date 1685383401736)
@@ -0,0 +1,47 @@
+#pragma once
+#include <vector>
+#include <cmath>
+
+class Neuron;
+
+struct Connection {
+    Neuron* prev;
+    Neuron* next;
+    double weight;
+};
+
+class Neuron {
+private:
+    std::vector<Connection> nextNeurons;
+    std::vector<Connection> prevNeurons;
+    double value;
+    double activate(double input) {
+        return static_cast<double>(1)/(1 + pow(M_E, -input);
+    }
+public:
+    void setNextNeurons(std::vector<Neuron> &nextNeurons) {
+        this->nextNeurons = nextNeurons;
+    }
+    void setPrevNeurons(std::vector<Neuron> &prevNeurons) {
+        this->prevNeurons = prevNeurons;
+    }
+    void setValue(double value) {
+        this->value = value;
+    }
+    void addValue(double value) {
+
+    }
+    double getValue() {
+        return this->value;
+    }
+    void fire() {
+        //use my value to activate, and propagate to the next neurons forward
+        double toTransfer = activate(value);
+
+        //now transfer that value to all the other neurons
+        //by multiplying it by the weights
+
+        for (Connection c : connections)
+            c.next->addValue(c.weight * toTransfer);
+    }
+};
\ No newline at end of file
Index: Assignment3/reference/Network.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment3/reference/Network.h b/Assignment3/reference/Network.h
new file mode 100644
--- /dev/null	(date 1685377241414)
+++ b/Assignment3/reference/Network.h	(date 1685377241414)
@@ -0,0 +1,19 @@
+#pragma once
+#include <vector>
+#include "Neuron.h"
+
+typedef std::vector<Neuron> Layer;
+
+class Network {
+private:
+    //2D vecotr
+    std::vector<Layer> layers;
+    double totalError;
+    double recentAverageError;
+    double recentAverageSmoothingFactor;
+public:
+    Network(std::vector<int> topology);
+    void feedForward(const std::vector<double>& inputVals);
+    void backProp(const std::vector<double>& targetVals);
+    void getResults(std::vector<double>& inputVals) const;
+};
\ No newline at end of file
Index: Assignment3/reference/Network.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment3/reference/Network.cpp b/Assignment3/reference/Network.cpp
new file mode 100644
--- /dev/null	(date 1685378883674)
+++ b/Assignment3/reference/Network.cpp	(date 1685378883674)
@@ -0,0 +1,103 @@
+#include "Network.h"
+#include <iostream>
+#include <cmath>
+using namespace std;
+
+Network::Network(std::vector<int> topology) {
+    for (int i = 0; i < topology.size(); i++) {
+        //add the layer (the column)
+        layers.push_back(Layer());
+
+        //outputs = number of neurons in the next layer
+        int numberOfOutputs;
+        if (i == topology.size() - 1) //last layer, no outputs
+            numberOfOutputs = 0;
+        else
+            numberOfOutputs = topology[i + 1];
+
+
+
+        //add the neurons in the layer
+        for (int neuron = 0; neuron <= topology[i]; neuron++) {
+            //append to the most recently added layer
+            layers.back().push_back(Neuron(numberOfOutputs, neuron));
+            cout << "Made a neuron" << endl;
+        }
+    }
+}
+
+void Network::feedForward(const std::vector<double> &inputVals) {
+    //number of input values has to be equal to number of input neurons
+    if (inputVals.size() != layers[0].size() - 1)
+        throw "Number of input values != number of input neurons";
+
+
+    //set the values in the first layer
+    for (int i = 0; i < inputVals.size(); i++) {
+        layers[0][i].setOutputValue(inputVals[i]);
+    }
+
+    //propagate forward on each neuron in each layer to the next layer
+    for (int layerNum = 1; layerNum < layers.size(); layerNum++) {
+        Layer &prevLayer = layers[layerNum - 1];
+        for (int j = 0; j < layers[layerNum].size() - 1; j++)
+            layers[layerNum][j].feedForward(prevLayer);
+    }
+}
+
+void Network::backProp(const std::vector<double>& targetVals) {
+
+    //cacluate entire network error (RMS)
+    Layer& outputLayer = layers.back();
+
+    totalError = 0;
+
+    for (int i = 0; i < outputLayer.size() - 1; i++) {
+        double delta = targetVals[i] - outputLayer[i].getOutputValue();
+        totalError += delta * delta;
+    }
+
+    totalError /= outputLayer.size() - 1; //average
+    totalError = sqrt(totalError); //RMS
+
+    //to see how well NN is peforming
+    recentAverageError = (recentAverageError * recentAverageSmoothingFactor + totalError)
+            / (recentAverageSmoothingFactor + 1);
+
+    cout << "output layer size: " << outputLayer.size() << endl;
+    cout << "target vals size: " << targetVals.size() << endl;
+    //calculate output layer delta
+    for (int i = 0; i < outputLayer.size(); i++) {
+        outputLayer[i].calculateOutputGradients(targetVals[i]);
+    }
+
+    //calculate gradients of hidden layers
+    for (int layerNum = layers.size() - 2; layerNum > 0; --layerNum) {
+        Layer& hiddenLayer = layers[layerNum];
+        Layer& nextLayer = layers[layerNum + 1];
+
+        for (int i = 0; i < hiddenLayer.size(); i++)
+            hiddenLayer[i].calculateHiddenGradients(nextLayer);
+    }
+
+    //update weights
+
+    for (int layerNum = layers.size() - 1; layerNum > 0; --layerNum) {
+        Layer& layer = layers[layerNum];
+        Layer& prevLayer = layers[layerNum - 1];
+
+        for (int i = 0; i < layers.size(); i++) {
+            layer[i].updateInputWeights(prevLayer);
+        }
+    }
+}
+
+void Network::getResults(std::vector<double> &resultVals) const {
+    resultVals.clear();
+
+    for (int i = 0; i < layers.back().size() - 1; i++) {
+        cout << layers.back()[0].getOutputValue() << endl;
+        cout << layers.back()[1].getOutputValue() << endl;
+        resultVals.push_back(layers.back()[i].getOutputValue());
+    }
+}
\ No newline at end of file
Index: Assignment3/reference/Neuron.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment3/reference/Neuron.cpp b/Assignment3/reference/Neuron.cpp
new file mode 100644
--- /dev/null	(date 1685378425318)
+++ b/Assignment3/reference/Neuron.cpp	(date 1685378425318)
@@ -0,0 +1,88 @@
+#include "Neuron.h"
+#include <cmath>
+
+Neuron::Neuron(int numberOfOutputs, int index) {
+    for (int i = 0; i < numberOfOutputs; i++) {
+        Connection c;
+        c.weight = rand() / double(RAND_MAX);
+        outputWeights.push_back(c);
+    }
+
+    myIndex = index;
+    outputValue = 0;
+}
+
+void Neuron::setOutputValue(double value) {
+    outputValue = value;
+}
+
+double Neuron::getOutputValue() const {
+    return outputValue;
+}
+
+double Neuron::randomWeight() {
+    return rand() / double(RAND_MAX);
+}
+
+double activate(double sum) {
+    //use an activation
+    //function is tanh: output range [-1, 1]
+
+    return tanh(sum);
+}
+
+double transferActivation(double sum) {
+    return 1.0 - sum * sum;
+}
+
+void Neuron::feedForward(const Layer &prev) {
+    //sum up the inputs and use the activation function
+    //to propagate it
+
+    double sum = 0;
+
+    for (int i = 0; i < prev.size(); i++) {
+        sum += prev[i].getOutputValue() *
+                prev[i].outputWeights[myIndex].weight;
+    }
+
+    outputValue = activate(sum);
+}
+
+void Neuron::calculateOutputGradients(double targetValue) {
+    double delta = targetValue - outputValue;
+    gradient = delta * transferActivation(outputValue);
+}
+
+void Neuron::updateInputWeights(Layer &prevLayer) {
+    for (int i = 0; i < prevLayer.size(); i++) {
+        Neuron& neuron = prevLayer[i];
+        double oldDeltaWeight = neuron.outputWeights[myIndex].deltaWeight;
+
+        //alpha = momentum
+        //eta = learning rate
+        double newDeltaWeight = eta * neuron.getOutputValue() * gradient
+                + alpha * oldDeltaWeight;
+
+        neuron.outputWeights[myIndex].deltaWeight = newDeltaWeight;
+        neuron.outputWeights[myIndex].weight += newDeltaWeight;
+    }
+}
+
+double Neuron::sumDOW(const Layer& nextLayer) {
+    double sum = 0;
+
+    for (int i = 0; i < nextLayer.size() - 1; i++) {
+        sum += outputWeights[i].weight * nextLayer[i].gradient;
+    }
+
+    return sum;
+}
+
+void Neuron::calculateHiddenGradients(const Layer &nextLayer) {
+    double dow = sumDOW(nextLayer);
+    gradient = dow * transferActivation(outputValue);
+}
+
+double Neuron::eta = 0.15;
+double Neuron::alpha = 0.5;
Index: Assignment3/reference/makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment3/reference/makefile b/Assignment3/reference/makefile
new file mode 100644
--- /dev/null	(date 1685378723510)
+++ b/Assignment3/reference/makefile	(date 1685378723510)
@@ -0,0 +1,12 @@
+main:
+	g++ -c -g *.cpp
+	g++ -o main *.o
+
+run: main
+	./main
+
+clean:
+	rm *.o main
+
+val:
+	valgrind --leak-check=full ./main
\ No newline at end of file
Index: Assignment3/reference/Neuron.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment3/reference/Neuron.h b/Assignment3/reference/Neuron.h
new file mode 100644
--- /dev/null	(date 1685377374468)
+++ b/Assignment3/reference/Neuron.h	(date 1685377374468)
@@ -0,0 +1,31 @@
+#pragma once
+#include <vector>
+
+struct Connection
+{
+    double weight;
+    double deltaWeight;
+};
+
+class Neuron;
+typedef std::vector<Neuron> Layer;
+
+class Neuron{
+private:
+    double outputValue;
+    std::vector<Connection> outputWeights;
+    double sumDOW(const Layer& nextLayer);
+    int myIndex;
+    double randomWeight();
+    double gradient;
+    static double eta;
+    static double alpha;
+public:
+    Neuron(int numberOfOutputs, int myIndex);
+    void setOutputValue(double value);
+    double getOutputValue() const;
+    void feedForward(const Layer& prevLayer);
+    void calculateOutputGradients(double targetValue);
+    void calculateHiddenGradients(const Layer& nextLayer);
+    void updateInputWeights(Layer& prevLayer);
+};
\ No newline at end of file
